in readme.md, correct the path to example.log
in sample yaml should be -output (- fails)
the generated AI examples are all false!
the first ai test is the public test
when iterating on ai tests, it is asked to correct the flow, but the original flow is not given

it seems to generate too many functions, but it is easier to test.
The functions inputs can't be generated by AI, because they may have constraints that are not easy for LLM to generate.

idea: add import in functions, so it does not forget it.

in runing in AI input, it can be asked to check if implementation matches the part of algo.
Also if argument is not valid, the calling function should be corrected.

TODO global code in main()

It seems public tests reasoning is disabled. why not to emable it?

how chatGPT can create long inputs?
generate code structure
    Add explanation of testcases.
    test cases are repeated in refection. remove it from problem explanation.
    Main body is gerated here
generate function body:
    Do we need the final "Your output should follow this structure"?
    Can main() body change or remain intakt?




You are given a code contest problem, and a self-reflection on the problem.


problem description:
=====
You are given two arrays of integers a_1, a_2, …, a_n and b_1, b_2, …, b_m.

You need to insert all elements of b into a in an arbitrary way. As a result you will get an array c_1, c_2, …, c_{n+m} of size n + m.

Note that you are not allowed to change the order of elements in a, while you can insert elements of b at arbitrary positions. They can be inserted at the beginning, between any elements of a, or at the end. Moreover, elements of b can appear in the resulting array in any order.

What is the minimum possible number of inversions in the resulting array c? Recall that an inversion is a pair of indices (i, j) such that i < j and c_i > c_j.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains two integers n and m (1 ≤ n, m ≤ 10^6).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

The third line of each test case contains m integers b_1, b_2, …, b_m (1 ≤ b_i ≤ 10^9).

It is guaranteed that the sum of n for all tests cases in one input doesn't exceed 10^6. The sum of m for all tests cases doesn't exceed 10^6 as well.

Output

For each test case, print one integer — the minimum possible number of inversions in the resulting array c.

Example

Input


3
3 4
1 2 3
4 3 2 1
3 3
3 2 1
1 2 3
5 4
1 3 5 3 1
4 3 6 1


Output


0
4
6

Note

Below is given the solution to get the optimal answer for each of the example test cases (elements of a are underscored).

  * In the first test case, c = [\underline{1}, 1, \underline{2}, 2, \underline{3}, 3, 4].
  * In the second test case, c = [1, 2, \underline{3}, \underline{2}, \underline{1}, 3].
  * In the third test case, c = [\underline{1}, 1, 3, \underline{3}, \underline{5}, \underline{3}, \underline{1}, 4, 6].
=====


self-reflection on the problem:
============
- The problem revolves around inserting elements from one array (b) into another (a) to form a new array (c).
- The objective is to minimize the number of inversions in the resulting array. An inversion occurs when a larger number precedes a smaller one.
- The order of elements in array a must remain unchanged. However, elements from b can be inserted in any order and position relative to a.
- We are given multiple test cases. Each test case consists of two lines following the line that mentions the number of test cases.
- The first line of each test case specifies the sizes of arrays a (n) and b (m), and the next two lines list their elements.
- The constraints for the test cases are outlined (1 ≤ n, m ≤ 10^6, 1 ≤ a_i, b_i ≤ 10^9), including the total sum of n and m for all test cases.
- The required output is the minimum number of inversions in the array c for each test case.
- The problem description includes example test cases with their inputs and the expected outputs, illustrating how the insertion should be done to achieve the minimum inversions.
============


Here are also explanations for the problem test cases:
============
- input: |
    3
    3 4
    1 2 3
    4 3 2 1
    3 3
    3 2 1
    1 2 3
    5 4
    1 3 5 3 1
    4 3 6 1
  output: |
    0
    4
    6
  explanation: |
    - These examples follow the problem format: a number indicating test cases, followed by each case with array sizes and elements.
    - Test 1: Demonstrates no inversions are necessary. The elements of b are inserted in such a way that they do not create any inversions with elements of a.
    - Test 2: Shows a case where inversions are unavoidable. The minimum number of inversions here is 4.
    - Test 3: Presents a more complex scenario with a larger array, where the minimum inversions are 6. This test checks the algorithm's effectiveness in a more intricate setup.
    - The examples cover different scenarios and validate the problem's rules and constraints, ensuring the solution must handle varying degrees of complexity and different arrangements.
============

Your goal is to generate a valid Python implementation for all functions of the following code structure, according to the following algorithm:
Algorithm:
=============
possible_solutions:
  - name: |
      Greedy Insertion with Preprocessing
    key_observations:
      - "The order of elements in array a must remain unchanged, but elements of b can be inserted in any order."
      - "Inversions are minimized when each element of b is inserted in a position where it causes the least inversions with elements of a."
      - "For each element in b, the optimal position is between elements of a that are both greater than or equal to it, to avoid inversions."
      - "A preprocessing step is needed to efficiently find the optimal position for each element of b."
    content: |
      The solution involves two main steps:
      1. Preprocessing array a to find the optimal insertion points for the elements of b. This can be done by creating a sorted version of a and using binary search to find the optimal insertion points for each element of b.
      2. Iterating over each element of b, finding its optimal insertion point using the preprocessed data, and inserting it into the array c at that position. The array c is initially a copy of a, and elements of b are inserted into it one by one.
    why_it_works: |
      This solution works because it minimizes the inversions by carefully choosing where to insert each element of b. By using binary search on the sorted version of a, the algorithm quickly finds the position where the element of b will cause the fewest inversions. The preprocessing step ensures that the insertion points can be found efficiently for each element of b.
    labels:
      - greedy
      - binary search
      - preprocessing
      - sorting
    complexity: |
      The time complexity is O(n log n + m log n) where n is the size of array a, and m is the size of array b. This includes the time for sorting array a and performing binary search for each element of b. The space complexity is O(n), needed for the sorted version of array a.
=============

Code Structure:
=============
def binary_search(arr, x):
    """
    Performs binary search in the sorted array arr to find the position of x.
    Calls nothing.
    Returns the index where x should be inserted in arr.
    """
    # Implement binary search
    return index

def preprocess_array_a(arr_a):
    """
    Sorts the array a and prepares it for binary search.
    Calls nothing.
    Returns the sorted array.
    """
    # Sort array a
    return sorted_arr_a

def find_optimal_insertions(arr_a, arr_b, sorted_arr_a):
    """
    Finds optimal insertion points for each element of b in array a.
    Calls binary_search().
    Returns a list of positions where elements of b should be inserted in arr_a.
    """
    # Find optimal positions for each element in b
    return insertion_positions

def insert_elements(arr_a, arr_b, insertion_positions):
    """
    Inserts elements of b into a at their optimal positions.
    Calls nothing.
    Returns the final array c.
    """
    # Insert elements of b into a at calculated positions
    return arr_c

def count_inversions(arr):
    """
    Counts the number of inversions in the array.
    Calls nothing.
    Returns the total number of inversions.
    """
    # Count inversions
    return inversions

def main():
    """
    Main execution flow of the program.
    Reads input, calls preprocess_array_a(), find_optimal_insertions(), insert_elements(), and count_inversions().
    """
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, m = map(int, input().split())
        arr_a = list(map(int, input().split()))
        arr_b = list(map(int, input().split()))

        sorted_arr_a = preprocess_array_a(arr_a)
        insertion_positions = find_optimal_insertions(arr_a, arr_b, sorted_arr_a)
        arr_c = insert_elements(arr_a, arr_b, insertion_positions)
        inversions = count_inversions(arr_c)

        print(inversions)

if __name__ == "__main__":
    main()
=============

Guidelines:
- Use  meaningful names for parameters and variables.
- Double-check each function. It should implement the part of algorithm in its comments, and generalize to any valid parameters, and not just the provided examples.
- Make sure to address the problem constraints.
- Add necessary imports.
- Output should be a self-contained code.
- Keep the code structure and the comments intact.

Answer:
```python
"""

