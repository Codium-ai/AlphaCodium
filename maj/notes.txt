in readme.md, correct the path to example.log
in sample yaml should be -output (- fails)
the generated AI examples are all false!
the first ai test is the public test
when iterating on ai tests, it is asked to correct the flow, but the original flow is not given

it seems to generate too many functions, but it is easier to test.
The functions inputs can't be generated by AI, because they may have constraints that are not easy for LLM to generate.

idea: add import in functions, so it does not forget it.

in runing in AI input, it can be asked to check if implementation matches the part of algo.
Also if argument is not valid, the calling function should be corrected.

TODO global code in main()

It seems public tests reasoning is disabled. why not to emable it?

generate_ai_tests
  how chatGPT can create long inputs?
  #FIXME adding public tests to the beginning and end of the list: But AI tests have no output!

run_generate_possible_solutions.python
   remove_bruce_force_solutions is set to true (in upstream), but we instructed LLM to generate it if no better solution.

run_choose_best_solution
    when generating the solutions, LLM automatically generates numbered steps (we can explicitly ask it to do so). it seems when choosing the best one, it simply copy-pastes it. so flow is not necessary.




You are given a code contest problem:
=============
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
=============

a self-reflection on the problem:
======
- The problem is about sorting a list of book titles in a unique way. Andi and Budi have a bookshelf with 'n' books, each represented by a string of length 'm'. They want to sort these books in an "asc-desc-ending" order. This means that when comparing two book titles, the characters at odd positions are compared in ascending order (A before B), while the characters at even positions are compared in descending order (Z before A).

- The input consists of two integers 'n' and 'm', followed by 'n' lines each containing a string of length 'm'. These strings represent the book titles. The output should be 'n' integers representing the indices of the book titles after they are sorted in "asc-desc-ending" order.

- The problem has a constraint that the product of 'n' and 'm' should be less than or equal to 10^6. Also, all book titles are distinct and consist of uppercase Latin letters.
======

and an Algorithm for the problem:
=============
name: "Custom Sorting"
key_observations:
  - "We need to sort the book titles in a unique way, where characters at odd positions are compared in ascending order and characters at even positions are compared in descending order."
  - "We can achieve this by creating a custom comparator function that implements this logic."
content: |
  1. Read the input book titles and store them along with their original indices in a list of pairs.
  2. Sort the list using a custom comparator function. The function should compare two book titles as follows:
     - Iterate over the characters of the two strings. For each position, if the characters are different, return the comparison result based on whether the position is odd or even. If it's odd, return the result of comparing the characters in ascending order. If it's even, return the result of comparing them in descending order.
     - If all characters are equal (which should not happen as all book titles are distinct), return false.
  3. After sorting, output the original indices of the book titles in their new order.
why_it_works: |
  This solution works because it correctly implements the unique sorting rule described in the problem. The custom comparator function ensures that book titles are compared correctly based on the position of their differing character. By storing the original indices of the book titles, we can output them in their new order after sorting.
labels:
  - "sorting"
  - "custom comparator"
complexity: |
  The time complexity is O(n*m*log(n)), where n is the number of book titles and m is the length of each title. This is because we perform a sort operation on n elements, and comparing two elements takes O(m) time. The space complexity is O(n), which is used to store the book titles and their original indices.
why_is_best_solution: |
  This solution is the best because it directly addresses the problem's requirements and constraints. It uses a custom sorting function to sort the book titles according to the unique rule specified in the problem. This solution is also efficient, with a time complexity of O(n*m*log(n)), which is acceptable given the problem's constraints. Furthermore, it is simple and easy to understand, making it a robust solution.
=============

The code below is an implementation of the algorithm. But its output on a test input is wrong:

Code:
=================
import sys
from functools import cmp_to_key

def read_input():
    '''
    Reads the input book titles and store them along with their original indices in a list of pairs.
    Calls nothing.
    Returns a list of pairs where each pair consists of a book title and its original index.
    '''
    n, m = map(int, input().strip().split())
    titles = []
    for i in range(n):
        title = input().strip()
        titles.append((title, i+1))
    return titles

def compare_titles(a, b):
    '''
    Custom comparator function that compares two book titles based on the unique sorting rule.
    Calls nothing.
    Returns a boolean value indicating whether book title a should come before book title b in the sorted list.
    '''
    for i in range(len(a[0])):
        if a[0][i] != b[0][i]:
            if i % 2 == 0:
                return a[0][i] < b[0][i]
            else:
                return a[0][i] > b[0][i]
    return False

def sort_titles(titles):
    '''
    Sorts the list of book titles using the custom comparator function.
    Calls compare_titles().
    Returns the sorted list of book titles along with their original indices.
    '''
    return sorted(titles, key=cmp_to_key(compare_titles))

def print_indices(sorted_titles):
    '''
    Prints the original indices of the book titles in their new order after sorting.
    Calls nothing.
    Returns nothing.
    '''
    for title in sorted_titles:
        print(title[1], end=" ")
    print()

def main():
    '''
    Main execution flow of the program.
    Calls read_input(), sort_titles(), and print_indices().
    '''
    titles = read_input()
    sorted_titles = sort_titles(titles)
    print_indices(sorted_titles)

if __name__ == "__main__":
    main()
=================

Test input:
=====================
5 2
AA
AB
BB
BA
AZ
=====================
Test output:
====================
5 2 1 3 4
====================

Code output:
====================
1 2 3 4 5
====================

Your task is to correct the code, according to the following analysis of the call stack:

Analysis of Call stack:
===================
output_formatting_correct: true
function_calls:
  function: "main"
  input: null
  valid_input: true
  return_value: null
  correct_return_value: true
  calls:
    - function: "read_input"
      input: null
      valid_input: true
      return_value: "[('AA', 1), ('AB', 2), ('BB', 3), ('BA', 4), ('AZ', 5)]"
      correct_return_value: true
      calls: []
    - function: "sort_titles"
      input: "[('AA', 1), ('AB', 2), ('BB', 3), ('BA', 4), ('AZ', 5)]"
      valid_input: true
      return_value: "[('AA', 1), ('AB', 2), ('BB', 3), ('BA', 4), ('AZ', 5)]"
      correct_return_value: false
      incorrect_return_value: "The sorting logic in compare_titles is incorrect. It should return -1, 0, or 1, not a boolean."
      calls:
        - function: "compare_titles"
          input: "('AB', 2), ('AA', 1)"
          valid_input: true
          return_value: "True"
          correct_return_value: false
          incorrect_return_value: "Should compare for sorting, not return boolean. The logic should account for ascending and descending order properly."
          calls: []
        - function: "compare_titles"
          input: "('BB', 3), ('AB', 2)"
          valid_input: true
          return_value: "False"
          correct_return_value: false
          incorrect_return_value: "Misinterpretation of the sorting logic for odd and even positions."
          calls: []
        - function: "compare_titles"
          input: "('BA', 4), ('BB', 3)"
          valid_input: true
          return_value: "False"
          correct_return_value: false
          incorrect_return_value: "Incorrect handling of even-positioned character comparison."
          calls: []
        - function: "compare_titles"
          input: "('AZ', 5), ('BA', 4)"
          valid_input: true
          return_value: "True"
          correct_return_value: false
          incorrect_return_value: "Incorrect comparison logic for odd and even positions."
          calls: []
    - function: "print_indices"
      input: "[('AA', 1), ('AB', 2), ('BB', 3), ('BA', 4), ('AZ', 5)]"
      valid_input: true
      return_value: null
      correct_return_value: true
      calls: []
additional_comments: "The primary issue lies within the compare_titles function, where the return type and comparison logic do not align with the requirements for custom sorting in Python. The compare_titles function should return an integer indicating the sort order rather than a boolean. This misalignment causes the sort_titles function to not sort the titles as expected per the unique asc-desc-ending order."
===================

Guidelines:
- The correction should be based on the analysis of call stack.
- Give the whole new code.
- Make just the necessary changes. Keep the program structure, if possible.
- The code should read the input using the 'input()' method. The output should be printed without additional words using the 'print()' method.

Answer:
```python